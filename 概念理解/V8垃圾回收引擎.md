# V8垃圾回收引擎

## 一、背景

V8在执行JS代码中，遇到函数会创建一个执行上下文环境并添加到堆栈的栈顶，函数的作用域包含函数中声明的所有变量，当函数执行完之后，执行上下文会从栈顶弹出，作用域被销毁，所有变量会被释放和自动回收。

## 二、原因

如果在作用域被销毁时，变量不被回收的话，会持久的占用内存，导致内存暴增，从而引发内存泄漏，所以，我们需要保证变量被及时回收。

## 三、回收方式

### 设置V8的内存限制

没错，就是这么简单粗暴，V8引擎在64位系统下约有1.4G的内存，在32位系统下约有0.7G的内存，为什么设置的这么低？

1. 由于javascript的单线程机制：js的单线程机制使得浏览器执行代码只能从头到尾按顺序执行，当中间遇到复杂或者开销很大的操作时，其他任务会被搁置，优先解决当前问题。比如垃圾回收机制，所以设置V8引擎的内存限制是保证不阻碍主线程逻辑的执行。
2. 垃圾回收机制：垃圾回收机制本身是一件很耗时的操作，根据网文，假设V8的堆内存为1.5G，做一次垃圾回收需要50ms以上，而作一次非增量式回收需要1s以上，会对动画会造成掉帧的后果，严重影响浏览器型性能和用户体验度，等待时间越久，浏览器越得不到响应。

所以，基于以上两点，需要设置内存限制，为什么这么低？因为在浏览器端一般不会遇到需要操作几个G的场景。但是，在Node端，涉及到I\O操作的，可能会遇到，不过我们可以手动配置。启动node时，可以传递--max-old-space-size或--max-new-space-size来调整内存限制的大小，前者确定老生代的大小，单位为MB，后者确定新生代的大小，单位为KB。这些配置只在V8初始化时生效，一旦生效不能再改变。

## 四、垃圾回收策略

V8引擎的垃圾回收机制策略主要是基于分代式垃圾回收机制，即根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的等分代采用不同的垃圾回收算法。

生代的主要种类：

- 新生代内存区：大多数的对象开始都会被分配在这，区域小但是垃圾回收频繁
- 老生代指针区：新生代存货一段时间后会被转移到老生代，这里包含了大多数可能存在指向其他对象指针的对象
- 老生代数据区：属于老生代，这里只保存缘使数据对象，没有指向其他值对象的指针
- 大对象区：存放超越其他区的大选哦的对象，每个对象都有自己的内存，垃圾回收其不会移动大对象
- 代码区：代码对象，唯一执行权限的内存区。
- Cell、Map区：存放Cell和Map，每个区域都存放相同大小的元素

不同的垃圾回收算法：

- Scavenge算法：针对<u>**新生代**</u>
- Mark-Sweep & Mark-Compact算法：老生代

## 五、避免内存泄漏

1. 尽可能少的创建全局变量
2. 手动清除定时器
3. 少用闭包
4. 清楚DOM引用
5. 使用弱引用

